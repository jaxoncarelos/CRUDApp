import {
  writable
} from "./chunk-DQWM4VI4.js";
import {
  fade
} from "./chunk-6UNMTC5H.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_style,
  space,
  text,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-TVA3GBF4.js";

// node_modules/svelte-notifications/src/context.js
var context = {
  subscribe: null,
  addNotification: null,
  removeNotification: null,
  clearNotifications: null
};
var getNotificationsContext = () => getContext(context);
var context_default = context;

// node_modules/svelte-notifications/src/components/Notification.svelte
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    return {
      props: {
        notification: ctx2[1],
        withoutStyles: ctx2[2],
        onRemove: ctx2[3]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 2)
        switch_instance_changes.notification = ctx2[1];
      if (dirty & 4)
        switch_instance_changes.withoutStyles = ctx2[2];
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Notification", slots, []);
  let { item } = $$props;
  let { notification = {} } = $$props;
  let { withoutStyles = false } = $$props;
  const { removeNotification: removeNotification2 } = getNotificationsContext();
  const { id, removeAfter } = notification;
  const removeNotificationHandler = () => removeNotification2(id);
  let timeout = null;
  if (removeAfter) {
    timeout = setTimeout(removeNotificationHandler, removeAfter);
  }
  onDestroy(() => {
    if (removeAfter && timeout)
      clearTimeout(timeout);
  });
  $$self.$$.on_mount.push(function() {
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<Notification> was created without expected prop 'item'");
    }
  });
  const writable_props = ["item", "notification", "withoutStyles"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Notification> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("notification" in $$props2)
      $$invalidate(1, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(2, withoutStyles = $$props2.withoutStyles);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    getNotificationsContext,
    item,
    notification,
    withoutStyles,
    removeNotification: removeNotification2,
    id,
    removeAfter,
    removeNotificationHandler,
    timeout
  });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("notification" in $$props2)
      $$invalidate(1, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(2, withoutStyles = $$props2.withoutStyles);
    if ("timeout" in $$props2)
      timeout = $$props2.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, notification, withoutStyles, removeNotificationHandler];
}
var Notification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      item: 0,
      notification: 1,
      withoutStyles: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notification",
      options,
      id: create_fragment.name
    });
  }
  get item() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notification() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notification(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withoutStyles() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withoutStyles(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Notification_default = Notification;

// node_modules/svelte-notifications/src/components/DefaultNotification.svelte
var file = "node_modules\\svelte-notifications\\src\\components\\DefaultNotification.svelte";
function add_css(target) {
  append_styles(target, "svelte-1x27qg3", ".default-notification-style.svelte-1x27qg3.svelte-1x27qg3{position:relative;display:flex;align-items:stretch;justify-content:space-between;margin:12px;background:#fff;color:#000;border-radius:6px;box-shadow:0 4px 10px rgba(0, 0, 0, 0.08);min-height:0;min-width:200px;overflow:hidden}.default-notification-style-content.svelte-1x27qg3.svelte-1x27qg3{width:210px;padding:12px 6px 12px 12px;box-sizing:border-box;word-wrap:break-word}.default-notification-style-button.svelte-1x27qg3.svelte-1x27qg3{display:block;width:40px;padding:0;margin:0;border:none;border-left:1px solid #eee;outline:none;background:none;cursor:pointer;font-size:20px;color:#000;box-sizing:border-box}.default-notification-style-button.svelte-1x27qg3.svelte-1x27qg3:hover{background:rgba(0, 0, 0, 0.01)}.default-notification-error.svelte-1x27qg3.svelte-1x27qg3{background:#f3555a;color:#fff}.default-notification-error.svelte-1x27qg3 .default-notification-style-button.svelte-1x27qg3{border-left:1px solid rgba(255, 255, 255, 0.4);color:#fff}.default-notification-warning.svelte-1x27qg3.svelte-1x27qg3{background:#ffb900;color:#000}.default-notification-warning.svelte-1x27qg3 .default-notification-style-button.svelte-1x27qg3{border-left:1px solid rgba(0, 0, 0, 0.2);color:#000}.default-notification-success.svelte-1x27qg3.svelte-1x27qg3{background:#22ce6c;color:#fff}.default-notification-success.svelte-1x27qg3 .default-notification-style-button.svelte-1x27qg3{border-left:1px solid rgba(255, 255, 255, 0.4);color:#fff}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVmYXVsdE5vdGlmaWNhdGlvbi5zdmVsdGUiLCJzb3VyY2VzIjpbIkRlZmF1bHROb3RpZmljYXRpb24uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzdHlsZT5cbiAgLmRlZmF1bHQtbm90aWZpY2F0aW9uLXN0eWxlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgbWFyZ2luOiAxMnB4O1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgY29sb3I6ICMwMDA7XG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgIGJveC1zaGFkb3c6IDAgNHB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcbiAgICBtaW4taGVpZ2h0OiAwO1xuICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgfVxuXG4gIC5kZWZhdWx0LW5vdGlmaWNhdGlvbi1zdHlsZS1jb250ZW50IHtcbiAgICB3aWR0aDogMjEwcHg7XG4gICAgcGFkZGluZzogMTJweCA2cHggMTJweCAxMnB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICB9XG5cbiAgLmRlZmF1bHQtbm90aWZpY2F0aW9uLXN0eWxlLWJ1dHRvbiB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgd2lkdGg6IDQwcHg7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2VlZTtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICBjb2xvcjogIzAwMDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG5cbiAgLmRlZmF1bHQtbm90aWZpY2F0aW9uLXN0eWxlLWJ1dHRvbjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjAxKTtcbiAgfVxuXG4gIC5kZWZhdWx0LW5vdGlmaWNhdGlvbi1lcnJvciB7XG4gICAgYmFja2dyb3VuZDogI2YzNTU1YTtcbiAgICBjb2xvcjogI2ZmZjtcbiAgfVxuXG4gIC5kZWZhdWx0LW5vdGlmaWNhdGlvbi1lcnJvciAuZGVmYXVsdC1ub3RpZmljYXRpb24tc3R5bGUtYnV0dG9uIHtcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcbiAgICBjb2xvcjogI2ZmZjtcbiAgfVxuXG4gIC5kZWZhdWx0LW5vdGlmaWNhdGlvbi13YXJuaW5nIHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZiOTAwO1xuICAgIGNvbG9yOiAjMDAwO1xuICB9XG5cbiAgLmRlZmF1bHQtbm90aWZpY2F0aW9uLXdhcm5pbmcgLmRlZmF1bHQtbm90aWZpY2F0aW9uLXN0eWxlLWJ1dHRvbiB7XG4gICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgY29sb3I6ICMwMDA7XG4gIH1cblxuICAuZGVmYXVsdC1ub3RpZmljYXRpb24tc3VjY2VzcyB7XG4gICAgYmFja2dyb3VuZDogIzIyY2U2YztcbiAgICBjb2xvcjogI2ZmZjtcbiAgfVxuXG4gIC5kZWZhdWx0LW5vdGlmaWNhdGlvbi1zdWNjZXNzIC5kZWZhdWx0LW5vdGlmaWNhdGlvbi1zdHlsZS1idXR0b24ge1xuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xuICAgIGNvbG9yOiAjZmZmO1xuICB9XG48L3N0eWxlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBmYWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG4gIGV4cG9ydCBsZXQgbm90aWZpY2F0aW9uID0ge307XG4gIGV4cG9ydCBsZXQgd2l0aG91dFN0eWxlcyA9IGZhbHNlO1xuICBleHBvcnQgbGV0IG9uUmVtb3ZlID0gbnVsbDtcblxuICBjb25zdCB7XG4gICAgdGV4dCxcbiAgICB0eXBlLFxuICB9ID0gbm90aWZpY2F0aW9uO1xuXG4gIGNvbnN0IGdldENsYXNzID0gKHN1ZmZpeCkgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRTdWZmaXggPSBzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJztcbiAgICBjb25zdCBkZWZhdWx0Tm90aWZpY2F0aW9uQ2xhc3MgPSBgIGRlZmF1bHQtbm90aWZpY2F0aW9uLXN0eWxlJHtkZWZhdWx0U3VmZml4fWA7XG4gICAgY29uc3QgZGVmYXVsdE5vdGlmaWNhdGlvblR5cGUgPSB0eXBlICYmICFzdWZmaXggPyBgIGRlZmF1bHQtbm90aWZpY2F0aW9uLSR7dHlwZX1gIDogJyc7XG5cbiAgICByZXR1cm4gYG5vdGlmaWNhdGlvbiR7ZGVmYXVsdFN1ZmZpeH0ke3dpdGhvdXRTdHlsZXMgPyAnJyA6IGRlZmF1bHROb3RpZmljYXRpb25DbGFzc30ke2RlZmF1bHROb3RpZmljYXRpb25UeXBlfWA7XG4gIH07XG48L3NjcmlwdD5cblxueyNpZiB0ZXh0fVxuICA8ZGl2XG4gICAgY2xhc3M9e2dldENsYXNzKCl9XG4gICAgcm9sZT1cInN0YXR1c1wiXG4gICAgYXJpYS1saXZlPVwicG9saXRlXCJcbiAgICBpbjpmYWRlXG4gICAgb3V0OmZhZGVcbiAgPlxuICAgIDxkaXYgY2xhc3M9e2dldENsYXNzKCdjb250ZW50Jyl9PlxuICAgICAgPHNsb3Q+e3RleHR9PC9zbG90PlxuICAgIDwvZGl2PlxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPXtnZXRDbGFzcygnYnV0dG9uJyl9XG4gICAgICBvbjpjbGljaz17b25SZW1vdmV9XG4gICAgICBhcmlhLWxhYmVsPVwiZGVsZXRlIG5vdGlmaWNhdGlvblwiXG4gICAgPlxuICAgICAgJnRpbWVzO1xuICAgIDwvYnV0dG9u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 */");
}
function create_if_block(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t0;
  let button;
  let t1;
  let button_class_value;
  let div1_class_value;
  let div1_intro;
  let div1_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      button = element("button");
      t1 = text("×");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-live": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      t1 = claim_text(button_nodes, "×");
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = null_to_empty(ctx[2]("content")) + " svelte-1x27qg3");
      add_location(div0, file, 102, 4, 2261);
      attr_dev(button, "class", button_class_value = null_to_empty(ctx[2]("button")) + " svelte-1x27qg3");
      attr_dev(button, "aria-label", "delete notification");
      add_location(button, file, 105, 4, 2336);
      attr_dev(div1, "class", div1_class_value = null_to_empty(ctx[2]()) + " svelte-1x27qg3");
      attr_dev(div1, "role", "status");
      attr_dev(div1, "aria-live", "polite");
      add_location(div1, file, 95, 2, 2159);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[5],
            !current ? get_all_dirty_from_scope(ctx[5]) : get_slot_changes(default_slot_template, ctx[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      add_render_callback(() => {
        if (div1_outro)
          div1_outro.end(1);
        div1_intro = create_in_transition(div1, fade, {});
        div1_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      if (div1_intro)
        div1_intro.invalidate();
      div1_outro = create_out_transition(div1, fade, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching && div1_outro)
        div1_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(95:0) {#if text}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(104:12) {text}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1])
        if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultNotification", slots, ["default"]);
  let { notification = {} } = $$props;
  let { withoutStyles = false } = $$props;
  let { onRemove = null } = $$props;
  const { text: text2, type } = notification;
  const getClass = (suffix) => {
    const defaultSuffix = suffix ? `-${suffix}` : "";
    const defaultNotificationClass = ` default-notification-style${defaultSuffix}`;
    const defaultNotificationType = type && !suffix ? ` default-notification-${type}` : "";
    return `notification${defaultSuffix}${withoutStyles ? "" : defaultNotificationClass}${defaultNotificationType}`;
  };
  const writable_props = ["notification", "withoutStyles", "onRemove"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DefaultNotification> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(3, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(4, withoutStyles = $$props2.withoutStyles);
    if ("onRemove" in $$props2)
      $$invalidate(0, onRemove = $$props2.onRemove);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    notification,
    withoutStyles,
    onRemove,
    text: text2,
    type,
    getClass
  });
  $$self.$inject_state = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(3, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(4, withoutStyles = $$props2.withoutStyles);
    if ("onRemove" in $$props2)
      $$invalidate(0, onRemove = $$props2.onRemove);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [onRemove, text2, getClass, notification, withoutStyles, $$scope, slots];
}
var DefaultNotification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        notification: 3,
        withoutStyles: 4,
        onRemove: 0
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultNotification",
      options,
      id: create_fragment2.name
    });
  }
  get notification() {
    throw new Error("<DefaultNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notification(value) {
    throw new Error("<DefaultNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withoutStyles() {
    throw new Error("<DefaultNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withoutStyles(value) {
    throw new Error("<DefaultNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRemove() {
    throw new Error("<DefaultNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRemove(value) {
    throw new Error("<DefaultNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultNotification_default = DefaultNotification;

// node_modules/svelte-notifications/src/positions.js
var positions = [
  "top-left",
  "top-center",
  "top-right",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var positions_default = positions;

// node_modules/svelte-notifications/src/store/actions/addNotification.js
var addNotification = (notification, store) => {
  if (!notification)
    return;
  const { update } = store;
  const safeNotification = {
    id: `${new Date().getTime()}-${Math.floor(Math.random() * 9999)}`,
    position: "bottom-center",
    text: "",
    ...notification
  };
  if (!positions_default.includes(notification.position))
    return;
  update((notifications) => {
    if (safeNotification.position.includes("top-")) {
      return [safeNotification, ...notifications];
    }
    return [...notifications, safeNotification];
  });
};
var addNotification_default = addNotification;

// node_modules/svelte-notifications/src/store/actions/removeNotification.js
var removeNotification = (notificationId, { update }) => {
  if (!notificationId)
    return;
  update((notifications) => notifications.filter(({ id }) => id !== notificationId));
};
var removeNotification_default = removeNotification;

// node_modules/svelte-notifications/src/store/actions/clearNotifications.js
var clearNotifications = (store) => store.set([]);
var clearNotifications_default = clearNotifications;

// node_modules/svelte-notifications/src/store/index.js
var createStore = () => {
  const store = writable([]);
  return {
    subscribe: store.subscribe,
    addNotification: (notification) => addNotification_default(notification, store),
    removeNotification: (notificationId) => removeNotification_default(notificationId, store),
    clearNotifications: () => clearNotifications_default(store)
  };
};
var store_default = createStore();

// node_modules/svelte-notifications/src/components/Notifications.svelte
var file2 = "node_modules\\svelte-notifications\\src\\components\\Notifications.svelte";
function add_css2(target) {
  append_styles(target, "svelte-t0tmtn", ".default-position-style-top-left.svelte-t0tmtn,.default-position-style-top-center.svelte-t0tmtn,.default-position-style-top-right.svelte-t0tmtn,.default-position-style-bottom-left.svelte-t0tmtn,.default-position-style-bottom-center.svelte-t0tmtn,.default-position-style-bottom-right.svelte-t0tmtn{position:fixed;max-width:400px}.default-position-style-top-left.svelte-t0tmtn{top:0;left:0}.default-position-style-top-center.svelte-t0tmtn{top:0;left:50%;transform:translateX(-50%)}.default-position-style-top-right.svelte-t0tmtn{top:0;right:0}.default-position-style-bottom-left.svelte-t0tmtn{bottom:0;left:0}.default-position-style-bottom-center.svelte-t0tmtn{bottom:0;left:50%;transform:translateX(-50%)}.default-position-style-bottom-right.svelte-t0tmtn{bottom:0;right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm90aWZpY2F0aW9ucy5zdmVsdGUiLCJzb3VyY2VzIjpbIk5vdGlmaWNhdGlvbnMuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzdHlsZT5cbiAgLmRlZmF1bHQtcG9zaXRpb24tc3R5bGUtdG9wLWxlZnQsXG4gIC5kZWZhdWx0LXBvc2l0aW9uLXN0eWxlLXRvcC1jZW50ZXIsXG4gIC5kZWZhdWx0LXBvc2l0aW9uLXN0eWxlLXRvcC1yaWdodCxcbiAgLmRlZmF1bHQtcG9zaXRpb24tc3R5bGUtYm90dG9tLWxlZnQsXG4gIC5kZWZhdWx0LXBvc2l0aW9uLXN0eWxlLWJvdHRvbS1jZW50ZXIsXG4gIC5kZWZhdWx0LXBvc2l0aW9uLXN0eWxlLWJvdHRvbS1yaWdodCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gIH1cblxuICAuZGVmYXVsdC1wb3NpdGlvbi1zdHlsZS10b3AtbGVmdCB7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gIH1cblxuICAuZGVmYXVsdC1wb3NpdGlvbi1zdHlsZS10b3AtY2VudGVyIHtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgfVxuXG4gIC5kZWZhdWx0LXBvc2l0aW9uLXN0eWxlLXRvcC1yaWdodCB7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICB9XG5cbiAgLmRlZmF1bHQtcG9zaXRpb24tc3R5bGUtYm90dG9tLWxlZnQge1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICB9XG5cbiAgLmRlZmF1bHQtcG9zaXRpb24tc3R5bGUtYm90dG9tLWNlbnRlciB7XG4gICAgYm90dG9tOiAwO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gIH1cblxuICAuZGVmYXVsdC1wb3NpdGlvbi1zdHlsZS1ib3R0b20tcmlnaHQge1xuICAgIGJvdHRvbTogMDtcbiAgICByaWdodDogMDtcbiAgfVxuPC9zdHlsZT5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IHNldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGltcG9ydCBOb3RpZmljYXRpb24gZnJvbSAnLi9Ob3RpZmljYXRpb24uc3ZlbHRlJztcbiAgaW1wb3J0IERlZmF1bHROb3RpZmljYXRpb24gZnJvbSAnLi9EZWZhdWx0Tm90aWZpY2F0aW9uLnN2ZWx0ZSc7XG5cbiAgaW1wb3J0IGNvbnRleHQgZnJvbSAnLi4vY29udGV4dCc7XG4gIGltcG9ydCBzdG9yZSBmcm9tICcuLi9zdG9yZSc7XG4gIGltcG9ydCBwb3NpdGlvbnMgZnJvbSAnLi4vcG9zaXRpb25zJztcblxuICBleHBvcnQgbGV0IGl0ZW0gPSBudWxsO1xuICBleHBvcnQgbGV0IHdpdGhvdXRTdHlsZXMgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCB6SW5kZXggPSBudWxsO1xuXG4gIGNvbnN0IGdldENsYXNzID0gKHBvc2l0aW9uID0gJycpID0+IHtcbiAgICBjb25zdCBkZWZhdWx0UG9zaXRpb25DbGFzcyA9IGAgZGVmYXVsdC1wb3NpdGlvbi1zdHlsZS0ke3Bvc2l0aW9ufWA7XG5cbiAgICByZXR1cm4gYHBvc2l0aW9uLSR7cG9zaXRpb259JHt3aXRob3V0U3R5bGVzID8gJycgOiBkZWZhdWx0UG9zaXRpb25DbGFzc31gO1xuICB9O1xuXG4gIHNldENvbnRleHQoY29udGV4dCwgc3RvcmUpO1xuPC9zY3JpcHQ+XG5cbjxzbG90Pjwvc2xvdD5cbjxkaXYgY2xhc3M9XCJub3RpZmljYXRpb25zXCI+XG4gIHsjZWFjaCBwb3NpdGlvbnMgYXMgcG9zaXRpb259XG4gICAgPGRpdlxuICAgICAgY2xhc3M9e2dldENsYXNzKHBvc2l0aW9uKX1cbiAgICAgIHN0eWxlOnotaW5kZXg9e3pJbmRleH1cbiAgICA+XG4gICAgICB7I2VhY2ggJHN0b3JlIGFzIG5vdGlmaWNhdGlvbiAobm90aWZpY2F0aW9uLmlkKX1cbiAgICAgICAgeyNpZiBub3RpZmljYXRpb24ucG9zaXRpb24gPT09IHBvc2l0aW9ufVxuICAgICAgICAgIDxOb3RpZmljYXRpb25cbiAgICAgICAgICAgIHtub3RpZmljYXRpb259XG4gICAgICAgICAgICB7d2l0aG91dFN0eWxlc31cbiAgICAgICAgICAgIGl0ZW09e2l0ZW0gfHwgRGVmYXVsdE5vdGlmaWNhdGlvbn1cbiAgICAgICAgICAvPlxuICAgICAgICB7L2lmfVxuICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuICB7L2VhY2h9XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDRSw4Q0FBZ0MsQ0FDaEMsZ0RBQWtDLENBQ2xDLCtDQUFpQyxDQUNqQyxpREFBbUMsQ0FDbkMsbURBQXFDLENBQ3JDLG9DQUFvQyxjQUFDLENBQUMsQUFDcEMsUUFBUSxDQUFFLEtBQUssQ0FDZixTQUFTLENBQUUsS0FBSyxBQUNsQixDQUFDLEFBRUQsZ0NBQWdDLGNBQUMsQ0FBQyxBQUNoQyxHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLEFBQ1QsQ0FBQyxBQUVELGtDQUFrQyxjQUFDLENBQUMsQUFDbEMsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsR0FBRyxDQUNULFNBQVMsQ0FBRSxXQUFXLElBQUksQ0FBQyxBQUM3QixDQUFDLEFBRUQsaUNBQWlDLGNBQUMsQ0FBQyxBQUNqQyxHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLEFBQ1YsQ0FBQyxBQUVELG1DQUFtQyxjQUFDLENBQUMsQUFDbkMsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxBQUNULENBQUMsQUFFRCxxQ0FBcUMsY0FBQyxDQUFDLEFBQ3JDLE1BQU0sQ0FBRSxDQUFDLENBQ1QsSUFBSSxDQUFFLEdBQUcsQ0FDVCxTQUFTLENBQUUsV0FBVyxJQUFJLENBQUMsQUFDN0IsQ0FBQyxBQUVELG9DQUFvQyxjQUFDLENBQUMsQUFDcEMsTUFBTSxDQUFFLENBQUMsQ0FDVCxLQUFLLENBQUUsQ0FBQyxBQUNWLENBQUMifQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let notification;
  let current;
  notification = new Notification_default({
    props: {
      notification: ctx[10],
      withoutStyles: ctx[1],
      item: ctx[0] || DefaultNotification_default
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(notification.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(notification.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(notification, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notification_changes = {};
      if (dirty & 8)
        notification_changes.notification = ctx2[10];
      if (dirty & 2)
        notification_changes.withoutStyles = ctx2[1];
      if (dirty & 1)
        notification_changes.item = ctx2[0] || DefaultNotification_default;
      notification.$set(notification_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notification.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notification.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notification, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(75:8) {#if notification.position === position}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = ctx[10].position === ctx[7] && create_if_block2(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[10].position === ctx[7]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(74:6) {#each $store as notification (notification.id)}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let div_class_value;
  let current;
  let each_value_1 = ctx[3];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[10].id;
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[4](ctx[7])) + " svelte-t0tmtn");
      set_style(div, "z-index", ctx[2]);
      add_location(div, file2, 69, 4, 1479);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 11) {
        each_value_1 = ctx2[3];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      if (dirty & 4) {
        set_style(div, "z-index", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(69:2) {#each positions as position}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t;
  let div;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let each_value = positions_default;
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "notifications");
      add_location(div, file2, 67, 0, 1415);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      if (dirty & 31) {
        each_value = positions_default;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $store;
  validate_store(store_default, "store");
  component_subscribe($$self, store_default, ($$value) => $$invalidate(3, $store = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Notifications", slots, ["default"]);
  let { item = null } = $$props;
  let { withoutStyles = false } = $$props;
  let { zIndex = null } = $$props;
  const getClass = (position = "") => {
    const defaultPositionClass = ` default-position-style-${position}`;
    return `position-${position}${withoutStyles ? "" : defaultPositionClass}`;
  };
  setContext(context_default, store_default);
  const writable_props = ["item", "withoutStyles", "zIndex"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Notifications> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("withoutStyles" in $$props2)
      $$invalidate(1, withoutStyles = $$props2.withoutStyles);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    Notification: Notification_default,
    DefaultNotification: DefaultNotification_default,
    context: context_default,
    store: store_default,
    positions: positions_default,
    item,
    withoutStyles,
    zIndex,
    getClass,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("withoutStyles" in $$props2)
      $$invalidate(1, withoutStyles = $$props2.withoutStyles);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, withoutStyles, zIndex, $store, getClass, $$scope, slots];
}
var Notifications = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { item: 0, withoutStyles: 1, zIndex: 2 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notifications",
      options,
      id: create_fragment3.name
    });
  }
  get item() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withoutStyles() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withoutStyles(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Notifications_default = Notifications;

// node_modules/svelte-notifications/src/index.js
var src_default = Notifications_default;
export {
  src_default as default,
  getNotificationsContext
};
//# sourceMappingURL=svelte-notifications.js.map
